<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Roof Inspection Tool Demo</title>

  <link href="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.css" rel="stylesheet">
  <link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.5.0/mapbox-gl-draw.css" rel="stylesheet">

  <style>
    html,body {height:100%;margin:0}
    #map {position:absolute;inset:0}
    .toolbar {
      position:absolute;left:12px;top:12px;display:flex;gap:8px;
      background:rgba(255,255,255,.92);border-radius:10px;padding:8px 10px;
      font:14px system-ui,sans-serif
    }
    .btn {border:0;background:#111;color:#fff;border-radius:8px;padding:8px 10px;cursor:pointer}
    .btn.alt {background:#e6e6e6;color:#111}
    .measure-card {
      position:absolute;right:12px;top:12px;background:rgba(255,255,255,.92);
      border-radius:10px;padding:12px 14px;font:16px/1.4 system-ui,sans-serif;
      box-shadow:0 1px 3px rgba(0,0,0,0.15);
    }
    .measure-card h3 {margin:0 0 6px;font-size:16px;}
    .measure-card p {margin:4px 0;}

    /* navigation mode buttons */
    .nav-modes {
      position:absolute;left:12px;top:50%;transform:translateY(-50%);
      display:flex;flex-direction:column;gap:4px;
      background:rgba(255,255,255,.92);border-radius:10px;padding:8px;
    }
    .nav-modes button {
      width:32px;height:32px;display:flex;align-items:center;justify-content:center;
      border:0;border-radius:6px;background:transparent;color:#111;cursor:pointer;
      font-size:16px;line-height:1;transition:background .2s;
    }
    .nav-modes button.active {background:#111;color:#fff}

    .pc-widget {
      position: absolute; left: 12px; top: 12px; z-index: 1000;
      width: 320px; padding: 10px; border-radius: 12px;
      background: rgba(0,0,0,.55); backdrop-filter: blur(6px);
      color: #fff; font: 13px/1.3 system-ui, sans-serif; border: 1px solid rgba(255,255,255,.12);
    }
    .pc-widget label { display:block; margin-bottom:4px; color:#ddd; font-size:12px; }
    .pc-row { display:flex; gap:6px; }
    .pc-row input{
      flex:1; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.15);
      background:rgba(255,255,255,.08); color:#fff; outline:none;
    }
    .pc-row input::placeholder{ color:rgba(255,255,255,.5); }
    .pc-row button{
      padding:8px 10px; border-radius:8px; border:0; font-weight:600; cursor:pointer;
      background:#fff; color:#000;
    }
    .pc-row button.secondary{ background:transparent; color:#fff; border:1px solid rgba(255,255,255,.2); }
    .pc-suggest{
      list-style:none; margin:6px 0 0; padding:0; max-height:180px; overflow:auto;
      border-radius:8px; border:1px solid rgba(255,255,255,.15); background:rgba(0,0,0,.7); display:none;
    }
    .pc-suggest[open]{ display:block; }
    .pc-suggest li{ padding:8px 10px; cursor:pointer; }
    .pc-suggest li:hover, .pc-suggest li[aria-selected="true"]{ background:rgba(255,255,255,.12); }
    .pc-error{
      margin-top:6px; padding:6px 8px; border-radius:8px; border:1px solid rgba(255,80,80,.35);
      background:rgba(255,80,80,.1); color:#ffd9d9; font-size:12px;
    }
  </style>
</head>
<body>
  <div id="map" aria-label="Satellite map for drawing roofs"></div>

  <div class="toolbar" role="toolbar" aria-label="Drawing tools">
    <button id="draw-poly" class="btn" aria-pressed="true">Draw</button>
    <button id="trash" class="btn alt">Clear</button>
  </div>

  <!-- Postcode Finder (top-left HUD) -->
  <div id="pc-widget" class="pc-widget">
    <label for="pc-input">UK postcode</label>
    <div class="pc-row">
      <input id="pc-input" placeholder="e.g. SW1A 1AA" autocomplete="off" />
      <button id="pc-find" type="button">Find</button>
      <button id="pc-clear" type="button" class="secondary">Clear</button>
    </div>
    <ul id="pc-suggest" class="pc-suggest" role="listbox" aria-expanded="false"></ul>
    <div id="pc-error" class="pc-error" hidden></div>
  </div>

  <div class="nav-modes" role="toolbar" aria-label="Navigation modes">
    <button aria-label="Orbit" data-mode="orbit" class="active">‚≠Æ</button>
    <button aria-label="Pan" data-mode="pan">‚úã</button>
    <button aria-label="Zoom" data-mode="zoom">üîç</button>
    <button aria-label="Fly" data-mode="fly">üïπ</button>
  </div>

  <div class="measure-card" role="status" aria-live="polite">
    <h3>Path or polygon</h3>
    <p id="perimeter">Perimeter: ‚Äì m</p>
    <p id="area">Area: ‚Äì m¬≤</p>
    <details>
      <summary>Estimated cost</summary>
      <p id="estimate">‚Äì</p>
    </details>
  </div>

  <script src="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.5.0/mapbox-gl-draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
    mapboxgl.accessToken = 'pk.eyJ1IjoicGRoMDQwNSIsImEiOiJjbWVvcHhyeWcwYmJpMm1xdmd0bXUzdDByIn0.6thOLX7aKDCd1POUgSPdSA';
    window.maplibregl = mapboxgl;

    const sensitivity = 0.25; // lower = less sensitive

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/satellite-streets-v12',
      center: [-2.0, 53.6],  // UK-ish
      zoom: 16,
      pitch: 45,
      bearing: -17,
      maxZoom: 22,
      antialias: true
    });
    window.map = map;

    map.addControl(new mapboxgl.NavigationControl({ showZoom:true, showCompass:true }), 'top-right');

    // reduce default drag rotation sensitivity
    map.on('rotatestart', e => {
      e.preventDefault();
      map.on('mousemove', onRotateDrag);
    });
    map.on('rotateend', () => {
      map.off('mousemove', onRotateDrag);
    });
    function onRotateDrag(e) {
      const bearingDelta = -e.movementX * 0.2 * sensitivity;
      const pitchDelta   =  e.movementY * 0.2 * sensitivity;
      map.rotateTo(map.getBearing() + bearingDelta, {duration: 0});
      map.setPitch(Math.max(0, Math.min(85, map.getPitch() + pitchDelta)));
    }

    const draw = new MapboxDraw({
      displayControlsDefault: false,
      controls: { polygon: true, trash: true },
      defaultMode: 'draw_polygon'
    });
    map.addControl(draw);
    const elPerimeter = document.getElementById('perimeter');
    const elArea = document.getElementById('area');
    const elEst = document.getElementById('estimate');

    // camera & flight plan defaults for simple coverage planning
    const camera = {
      sensorWidthMm: 13.2,
      sensorHeightMm: 8.8,
      imageWidthPx: 4000,
      imageHeightPx: 3000,
      focalMm: 8.8,
    };
    const plan = {
      altitudeM: 60,
      frontOverlap: 0.7,
      sideOverlap: 0.6,
      gsMps: 12,
      turnTimeSec: 5,
      climbRate: 3,
      descendRate: 4,
    };

    function coverageFrom(cam, p) {
      const { sensorWidthMm, sensorHeightMm, focalMm, imageWidthPx, imageHeightPx } = cam;
      const fx = (p.altitudeM * sensorWidthMm) / focalMm;
      const fy = (p.altitudeM * sensorHeightMm) / focalMm;
      const laneSpacing = fy * (1 - p.sideOverlap);
      const triggerDist = fx * (1 - p.frontOverlap);
      const photoRate = p.gsMps / Math.max(0.1, triggerDist);
      const exposureGap = 1 / photoRate + (cam.trigLatencySec || 0);
      return { fx, fy, laneSpacing, triggerDist, exposureGap };
    }

    function timeEstimateRect(Lm, Wm, cam, plan) {
      const { laneSpacing, triggerDist } = coverageFrom(cam, plan);
      const lanes = Math.ceil(Wm / laneSpacing);
      const laneLen = Lm;
      const surveyDist = lanes * laneLen;
      const travelTime = surveyDist / plan.gsMps + (lanes - 1) * plan.turnTimeSec;
      const photoCount = Math.ceil(laneLen / triggerDist) * lanes;
      return {
        lanes,
        laneLen,
        photoCount,
        surveyTimeSec: travelTime,
        approxMissionTimeSec:
          travelTime + plan.altitudeM / plan.climbRate + plan.altitudeM / plan.descendRate,
      };
    }

    function updateMeasurements() {
      const data = draw.getAll();
      if (!data.features.length) {
        elPerimeter.textContent = 'Perimeter: ‚Äì m';
        elArea.textContent = 'Area: ‚Äì m¬≤';
        elEst.textContent = '‚Äì';
        if (map.getSource('survey-grid')) {
          map.removeLayer('survey-grid-lines');
          map.removeSource('survey-grid');
        }
        return;
      }
      const polygon = data.features[0];
      const areaM2 = turf.area(polygon);
      const line = turf.polygonToLine(polygon);
      const perimeterM = turf.length(line, {units:'kilometers'}) * 1000;

      elArea.textContent = `Area: ${areaM2.toLocaleString(undefined,{maximumFractionDigits:2})} m¬≤`;
      elPerimeter.textContent = `Perimeter: ${perimeterM.toLocaleString(undefined,{maximumFractionDigits:2})} m`;

      const bbox = turf.bbox(polygon);
      const widthM = turf.distance([bbox[0], bbox[1]], [bbox[2], bbox[1]], {units:'meters'});
      const heightM = turf.distance([bbox[0], bbox[1]], [bbox[0], bbox[3]], {units:'meters'});
      const cov = coverageFrom(camera, plan);
      const lanes = Math.max(1, Math.ceil(widthM / cov.laneSpacing));
      const lines = [];
      for (let i = 0; i < lanes; i++) {
        const offset = i * cov.laneSpacing + cov.laneSpacing / 2;
        const start = turf.destination([bbox[0], bbox[1]], offset, 90, {units:'meters'});
        const end = turf.destination([bbox[0], bbox[3]], offset, 90, {units:'meters'});
        lines.push(turf.lineString([start.geometry.coordinates, end.geometry.coordinates]));
      }
      const grid = turf.featureCollection(lines);
      if (map.getSource('survey-grid')) {
        map.getSource('survey-grid').setData(grid);
      } else {
        map.addSource('survey-grid', { type: 'geojson', data: grid });
        map.addLayer({
          id: 'survey-grid-lines',
          type: 'line',
          source: 'survey-grid',
          paint: { 'line-color': '#00ffff', 'line-width': 2 }
        });
      }

      const rect = timeEstimateRect(heightM, widthM, camera, plan);
      const estimate = 49 + 0.45 * areaM2; // example pricing
      const mins = Math.round(rect.approxMissionTimeSec / 60);
      const batteries = Math.max(1, Math.ceil(rect.approxMissionTimeSec / (20 * 60)));
      elEst.textContent = `¬£${estimate.toFixed(2)} ‚Äî ${rect.photoCount} photos, ${mins} min, ${batteries} batt.`;
    }

    map.on('draw.create', updateMeasurements);
    map.on('draw.update', updateMeasurements);
    map.on('draw.delete', updateMeasurements);

    document.getElementById('draw-poly').addEventListener('click', () => draw.changeMode('draw_polygon'));
    document.getElementById('trash').addEventListener('click', () => { draw.deleteAll(); updateMeasurements(); });

    // navigation modes
    const modeBar = document.querySelector('.nav-modes');
    let mode = 'orbit';
    modeBar.addEventListener('click', (e) => {
      if (e.target.matches('button')) {
        mode = e.target.dataset.mode;
        modeBar.querySelectorAll('button').forEach(b => b.classList.toggle('active', b === e.target));
        if (mode === 'fly') {
          map.setPitch(85);
        } else {
          map.setPitch(45);
        }
      }
    });

    map.getCanvas().addEventListener('contextmenu', e => e.preventDefault());

    let dragStart, startBearing, startPitch, startZoom;
    function startOrbit(e) {
      dragStart = [e.clientX, e.clientY];
      startBearing = map.getBearing();
      startPitch = map.getPitch();
      document.addEventListener('mousemove', onOrbitRotate);
      document.addEventListener('mouseup', endInteraction);
    }
    function onOrbitRotate(e) {
      const dx = e.clientX - dragStart[0];
      const dy = e.clientY - dragStart[1];
      map.setBearing(startBearing - dx * 0.4 * sensitivity);
      map.setPitch(Math.max(0, Math.min(85, startPitch + dy * 0.4 * sensitivity)));
    }

    function startPan(e) {
      dragStart = [e.clientX, e.clientY];
      document.addEventListener('mousemove', onPan);
      document.addEventListener('mouseup', endInteraction);
    }
    function onPan(e) {
      const dx = e.clientX - dragStart[0];
      const dy = e.clientY - dragStart[1];
      map.panBy([-dx, -dy], {animate:false});
      dragStart = [e.clientX, e.clientY];
    }

    function startDragZoom(e) {
      dragStart = e.clientY;
      startZoom = map.getZoom();
      document.addEventListener('mousemove', onDragZoom);
      document.addEventListener('mouseup', endInteraction);
    }
    function onDragZoom(e) {
      const dy = e.clientY - dragStart;
      map.zoomTo(startZoom - dy / 100, {animate:false});
    }

    function endInteraction() {
      document.removeEventListener('mousemove', onOrbitRotate);
      document.removeEventListener('mousemove', onPan);
      document.removeEventListener('mousemove', onDragZoom);
      document.removeEventListener('mouseup', endInteraction);
    }

    function onMouseDown(e) {
      if (mode === 'pan' || (e.altKey && e.button === 1)) {
        startPan(e);
      } else if (mode === 'zoom' || (e.altKey && e.button === 2)) {
        startDragZoom(e);
      } else if (mode === 'fly') {
        if (e.button === 0) startPan(e);
        if (e.button === 2) startOrbit(e);
      } else {
        // orbit default
        startOrbit(e);
      }
    }
    map.getCanvas().addEventListener('mousedown', onMouseDown);

    const keys = {};
    window.addEventListener('keydown', e => { keys[e.code] = true; });
    window.addEventListener('keyup', e => { keys[e.code] = false; });
    function flyLoop() {
      if (mode === 'fly') {
        const step = 10;
        let off = [0,0];
        if (keys['KeyW']) off[1] -= step;
        if (keys['KeyS']) off[1] += step;
        if (keys['KeyA']) off[0] -= step;
        if (keys['KeyD']) off[0] += step;
        if (off[0] || off[1]) map.panBy(off, {animate:false});
      }
      requestAnimationFrame(flyLoop);
    }
    flyLoop();

    map.on('dblclick', e => {
      e.preventDefault();
      map.flyTo({center: e.lngLat});
    });

    window.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === 'f') {
        const data = draw.getAll();
        if (data.features.length) {
          const box = turf.bbox(data);
          map.fitBounds([[box[0], box[1]], [box[2], box[3]]], {padding:40});
        }
      }
    });
  </script>
  <script>
/* ==== Postcode Finder (vanilla) ======================================= */
(function () {
  // ---- config ----------------------------------------------------------
  // IMPORTANT: this must be your existing MapLibre map instance variable.
  // If yours is named differently, replace `map` below.
  const Map = window.map || window.mapInstance || window.maplibreMap || null;
  if (!Map || typeof Map.flyTo !== "function") {
    console.warn("[PostcodeFinder] MapLibre map not found. Make sure this script runs after you create the map.");
    return;
  }

  const $ = (id) => document.getElementById(id);
  const $input = $("pc-input");
  const $find = $("pc-find");
  const $clear = $("pc-clear");
  const $suggest = $("pc-suggest");
  const $error = $("pc-error");

  let highlight = 0;
  let suggestAbort = null;
  let marker = null;

  function normalise(raw) {
    const trimmed = (raw || "").trim().toUpperCase();
    const cleaned = trimmed.replace(/[^A-Z0-9 ]+/g, "").replace(/\s+/g, " ");
    const pretty = cleaned;
    const key = cleaned.replace(/\s+/g, "");
    return { pretty, key };
  }

  async function getJSON(url, signal) {
    const res = await fetch(url, { signal, headers: { Accept: "application/json" } });
    if (!res.ok) throw new Error("HTTP " + res.status);
    return res.json();
  }

  async function resolvePostcode(raw, signal) {
    const { key } = normalise(raw);
    if (!key) throw new Error("Enter a postcode");
    const url = "https://api.postcodes.io/postcodes/" + encodeURIComponent(key);
    const json = await getJSON(url, signal);
    if (json && json.status === 200 && json.result) {
      return {
        postcode: json.result.postcode || key,
        lat: json.result.latitude,
        lng: json.result.longitude,
        region: json.result.region,
        country: json.result.country
      };
    }
    throw new Error("Postcode not found");
  }

  async function searchSuggestions(q, signal) {
    const key = normalise(q).key;
    if (!key) return [];
    const url = "https://api.postcodes.io/postcodes?q=" + encodeURIComponent(key) + "&limit=5";
    const json = await getJSON(url, signal);
    if (json && json.status === 200 && Array.isArray(json.result)) {
      return json.result.map((r) => ({
        postcode: r.postcode,
        region: r.region,
        country: r.country,
        lat: r.latitude,
        lng: r.longitude
      }));
    }
    return [];
  }

  function showError(msg) {
    $error.textContent = msg;
    $error.hidden = !msg;
  }

  function clearSuggest() {
    $suggest.innerHTML = "";
    $suggest.removeAttribute("open");
    $suggest.setAttribute("aria-expanded", "false");
    highlight = 0;
  }

  function renderSuggest(items) {
    clearSuggest();
    if (!items.length) return;
    $suggest.setAttribute("open", "");
    $suggest.setAttribute("aria-expanded", "true");
    items.forEach((s, i) => {
      const li = document.createElement("li");
      li.setAttribute("role", "option");
      li.textContent = s.postcode + (s.region ? " ‚Äî " + s.region : "");
      if (i === 0) li.setAttribute("aria-selected", "true");
      li.addEventListener("mousedown", (e) => {
        e.preventDefault();
        go(s.postcode);
      });
      li.addEventListener("mouseenter", () => selectIndex(i));
      $suggest.appendChild(li);
    });
  }

  function selectIndex(i) {
    highlight = Math.max(0, Math.min($suggest.children.length - 1, i));
    [...$suggest.children].forEach((el, idx) =>
      el.setAttribute("aria-selected", idx === highlight ? "true" : "false")
    );
  }

  function placeMarker(lng, lat) {
    if (!marker) {
      const el = document.createElement("div");
      el.style.width = "14px"; el.style.height = "14px"; el.style.borderRadius = "9999px";
      el.style.background = "#4ade80";
      el.style.boxShadow = "0 0 0 2px #fff, 0 0 0 4px rgba(0,0,0,.35)";
      marker = new maplibregl.Marker({ element: el }).setLngLat([lng, lat]).addTo(Map);
    } else {
      marker.setLngLat([lng, lat]);
    }
  }

  function flyTo(lng, lat) {
    Map.flyTo({ center: [lng, lat], zoom: 18, speed: 1.2 });
  }

  async function go(postcode) {
    const raw = postcode ?? $input.value;
    showError("");
    try {
      const ac = new AbortController();
      const rec = await resolvePostcode(raw, ac.signal);
      placeMarker(rec.lng, rec.lat);
      flyTo(rec.lng, rec.lat);
      clearSuggest();
    } catch (e) {
      const msg = /404/.test(String(e)) || /not found/i.test(String(e)) ? "Postcode not found" : "Network error";
      showError(msg);
    }
  }

  // events
  $input.addEventListener("input", () => {
    showError("");
    const q = $input.value.trim();
    if (suggestAbort) suggestAbort.abort();
    if (!q) return clearSuggest();
    suggestAbort = new AbortController();
    const signal = suggestAbort.signal;
    // debounce 300ms
    clearTimeout($input._pcTimer);
    $input._pcTimer = setTimeout(async () => {
      try {
        const items = await searchSuggestions(q, signal);
        renderSuggest(items);
      } catch (_) {}
    }, 300);
  });

  $input.addEventListener("keydown", (e) => {
    if ($suggest.hasAttribute("open")) {
      if (e.key === "ArrowDown") { e.preventDefault(); selectIndex(highlight + 1); }
      else if (e.key === "ArrowUp") { e.preventDefault(); selectIndex(highlight - 1); }
      else if (e.key === "Enter")  { e.preventDefault(); go(($suggest.children[highlight]||{}).textContent?.split(" ‚Äî ")[0]); }
      else if (e.key === "Escape") { clearSuggest(); }
    } else if (e.key === "Enter") {
      e.preventDefault(); go();
    }
  });

  $find.addEventListener("click", () => go());
  $clear.addEventListener("click", () => { $input.value = ""; clearSuggest(); showError(""); });

  // optional: auto-focus for quick testing
  // $input.focus();
})();
  </script>
</body>
</html>
